#include "package.hpp"
#include "frill/misc/target_id.hpp"
#include <fstream>

inline std::string replace_separator(const std::string &str) {
  auto s = str;
  for (auto &c : s) {
    if (c == '\\') {
      c = '/';
    }
  }
  return s;
}

void package_to_hpp(const frill::fs::path &shader_folder,
                    const frill::fs::path &cache_folder,
                    const frill::fs::path &output_file) {
  std::ofstream os(output_file);
  os << "// this file is generated by frill, do not edit it manually"
     << std::endl;
  os << "#ifndef FRILL_SHADERS_H" << std::endl;
  os << "#define FRILL_SHADERS_H" << std::endl;
  os << "#include <cstdint>" << std::endl;
  os << "#include <cstdlib>" << std::endl;
  os << "#include <set>" << std::endl;
  os << "#include <string>" << std::endl;
  os << "#include <utility>" << std::endl;
  os << "#include <unordered_map>" << std::endl;
  os << std::endl;

  auto index =
      frill::load_json_file<frill::IndexFile>(shader_folder / "index.json");

  auto get_var = [&](const std::string &uid) {
    return "frill_shader_code_" + uid;
  };

  auto get_length = [&](const std::string &uid) {
    return "frill_shader_code_" + uid + "_len";
  };

  os << "namespace frill_shaders {" << std::endl;
  for (auto &target : index.targets) {
    const auto &uid = target.uid;
    auto shader = frill::read_file_binary(shader_folder / (uid + ".spv"));

    os << "constexpr const uint8_t " << get_var(uid) << "[] = {";

    size_t count = 0;
    for (auto byte : shader) {
      if (count % 10 == 0) {
        os << std::endl;
      }
      os << " " << int(byte);
      count++;
      if (count != shader.size()) {
        os << ",";
      }
    }

    os << "};" << std::endl;

    os << "constexpr size_t " << get_length(uid) << " = " << shader.size()
       << ";" << std::endl;
    os << std::endl;
  }

  os << R"(
struct TargetId {
  std::string path{};
  std::set<std::string> flags{};

  bool operator==(const TargetId& rhs) const {
    return path == rhs.path && flags == rhs.flags;
  }

  bool operator!=(const TargetId &rhs) const {
    return !(*this == rhs);
  }
};

template <typename T>
inline void hash_combine(std::size_t &seed, const T &val) {
  std::hash<T> hasher;
  seed ^= hasher(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

inline std::string replace_separator(const std::string &str) {
  auto s = str;
  for (auto &c : s) {
    if (c == '\\') {
      c = '/';
    }
  }
  return s;
}

template <typename It>
TargetId make_target_id(const std::string &path, It flag_start, It flag_end) {
  TargetId id;
  id.path = replace_separator(path);
  id.flags.insert(flag_start, flag_end);
  return id;
}
)" << std::endl;
  os << "} // namespace frill_shaders" << std::endl;

  os << R"(
namespace std {
template <> struct hash<frill_shaders::TargetId> {
  size_t operator()(const frill_shaders::TargetId &id) const {
    size_t seed = 0;
    frill_shaders::hash_combine(seed, id.path);
    for (auto &flag : id.flags) {
      frill_shaders::hash_combine(seed, flag);
    }
    return seed;
  }
};
} // namespace std
)" << std::endl;

  os << "namespace frill_shaders {" << std::endl;
  os << R"(
struct MemoryView {
  const uint8_t* code = nullptr;
  size_t size = 0;
};

// return (nullptr, 0) if not found
inline MemoryView
load(const char *path, const char **flags, uint32_t flag_count) {
  static std::unordered_map<TargetId, MemoryView> s_id_to_shader = {
)";
  // init id to shader mapping
  {
    size_t count = 0;
    for (auto &target : index.targets) {
      os << "{ " << std::endl;

      const auto &id = target.target;
      os << "{ " << std::quoted(replace_separator(id.path.string())) << ", { ";
      {
        size_t flag_count = 0;
        for (auto &flag : id.flags) {
          os << std::quoted(flag);
          flag_count++;
          if (flag_count != id.flags.size()) {
            os << "," << std::endl;
          }
        }
      }
      os << " }}," << std::endl;

      const auto &uid = target.uid;
      os << "{ " << get_var(uid) << ", " << get_length(uid) << " }"
         << std::endl;

      os << " }";
      if (count + 1 < index.targets.size()) {
        os << ",";
      }

      os << std::endl;
      count++;
    }
  }
  os << R"(
  };
  auto id = make_target_id(path, flags, flags + flag_count);
  auto it = s_id_to_shader.find(id);
  if (it == s_id_to_shader.end()) {
    return MemoryView{};
  }
  return it->second;
}
)" << std::endl;
  os << "} // namespace frill_shaders" << std::endl;
  os << std::endl;
  os << "#endif // FRILL_SHADERS_H" << std::endl;
  os.close();
}

bool header_file_outdated(const frill::fs::path &cache_folder,
                          const frill::fs::path &output_file) {
  // TODO on demand packaging
  return true;
}
